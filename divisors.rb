#The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:
#
#1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
#
#Let us list the factors of the first seven triangle numbers:
#
# 1: 1
# 3: 1,3
# 6: 1,2,3,6
#10: 1,2,5,10
#15: 1,3,5,15
#21: 1,3,7,21
#28: 1,2,4,7,14,28
#We can see that 28 is the first triangle number to have over five divisors.
#
#What is the value of the first triangle number to have over five hundred divisors?
##

require "mathn"

def triangle(n)
	(n+1)*(n.to_f/2)
end

def factor(n)
	result = Array.new
	primes = Prime.new
	p = primes.next
	while (n != 1) do
		if (n%p==0)	
			n = n/p
			result << p
		else
			p = primes.next
		end	
	end
	puts result.to_s
	result	
end

#def number_of_divisors(factors, n) 
#	if (n == 1) 
#		 return 1
#	end
#
#	if (factors.size==1)
#		return 2
#	end
#	
#	# N = jp1 + kp2 + lp3 ...
#	# 1 + j + k + l +...  j*k + j*l + k*l + ... j*k*l +  ...
#	# count number of individual primes and sum up
#	
#	h = Hash.new
#	factors.collect { |e| 
#		if (h[e] != nil) 
#			h[e] += 1 
#		else
#			h[e] = 1
#		end 
#	} 
#	puts h.to_s
#	# multiply different sum counts 
#	sum = 1 h.inject(0) { |r,e| r += e[1] }
#
#	ms = 2 #mask size
#	while (ms <= h.size) do
#		0.upto(ms-1) { |i| masked << h[i][1] 
#		ms += 1
#	end
#
#	sum
#end 

def bfn(n)
	sum = 0
	1.upto(n) { |i| 
		if (n%i == 0) 
			sum += 1
		end
	}
	sum		
end

def calc_divisors(factors, divisors) 
	if factors == nil || factors.size == 0 
		return divisors << 1
	end
	
	a = factors[0]	
	next_divisors = Array.new
	if (divisors.size > 0)
		next_divisors = divisors.collect { |e| e*a }	
	else
		divisors << a
	end
	next_divisors << divisors
	next_divisors.flatten!
	if (!next_divisors.include?(a)) 
		next_divisors << a
	end
	next_divisors.uniq!
	#puts "added #{a}: #{next_divisors.to_s}"

	return calc_divisors(factors[1, factors.size-1], next_divisors)		

end

#25200

i = 2 
divisors = Array.new

while (divisors.size < 500) do
	i += 1
	tri = triangle(i)
	factors = factor(tri)
	#divisors = bfn(tri)
	divisors = calc_divisors(factors, Array.new)
end
	puts tri.to_s << " number of divisors: " << divisors.sort.to_s << " size: #{divisors.size}"
